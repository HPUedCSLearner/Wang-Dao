// Daemon 运行在后台也称作“后台服务进程”
// 那么为什么要引入守护进程呢？
// 	由于在linux中，
// 每一个系统与用户进行交流的界面称为终端，每一个从此终端开始运行的进程都会依赖这
// 个终端，这个终端就称为这些进程的控制终端。当控制终端被关闭时，相应的进程都会自
// 动关闭。但是守护进程却能突破这种限制，它被执行开始运转，直到整个系统关闭时才退
// 出。几乎所有的服务器程序如 Apache 和 wu-FTP，都用 daemon 进程的形式实现。很多 Linux
// 下常见的命令如 inetd 和 ftpd，末尾的字母 d 通常就是指 daemon。
// 
// 守护进程的特性：
// 1> 守护进程最重要的特性是后台运行。
// 2> 其次，守护进程必须与其运行前的环境隔离开来。这些环境包括未关闭的文件描述
// 符、控制终端、会话和进程组、工作目录已经文件创建掩码等。这些环境通常是守护进程
// 从父进程那里继承下来的。
// 3> 守护进程的启动方式
// daemon 进程的编程规则
// ⚫ 创建子进程，父进程退出：
//
// 进程组、会话周期、控制终端：
//
// 进程组：是一个或多个进程的集合。进程组有进程组 ID 来唯一标识。除了进程号(PID)
// 之外，进程组 ID（GID）也是一个进程的必备属性。每个进程都有一个组长进程，其组长
// 进程的进程号等于进程组 ID。且该进程组 ID 不会因为组长进程的退出而受影响。
// 会话周期：会话期是一个或多个进程组的集合。通常，一个会话开始于用户登录，终止
// 于用户退出，在此期间该用户运行的所有进程都属于这个会话期。
// 控制终端：由于在 linux 中，每一个系统与用户进行交流的界面称为终端，每一个从此
// 终端开始运行的进程都会依赖这个控制终端。


//通过查看vi /var/log/messages
//老问题了，在docker linux下看不到syslog
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <syslog.h>
#include <sys/stat.h>
#include <time.h>
int main()
{
	int i = 0;
	if(fork() > 0)
		exit(0);
	setsid();
	chdir("/");
	umask(0);
	for(; i < 3; i++)
	{
		close(i);
	}
	i = 0;
	while(i < 10)
	{
		printf("%d\n",i);
		time_t ttime;
		time(&ttime);
		struct tm *pTm = gmtime(&ttime);
		syslog(LOG_INFO,"%d %04d:%02d:%02d", i, (1900 + pTm->tm_year), (1 +
					pTm->tm_mon), (pTm->tm_mday));
		i++;
		sleep(2);
	}
}
