// Daemon 运行在后台也称作“后台服务进程”
// 那么为什么要引入守护进程呢？
// 	由于在linux中，
// 每一个系统与用户进行交流的界面称为终端，每一个从此终端开始运行的进程都会依赖这
// 个终端，这个终端就称为这些进程的控制终端。当控制终端被关闭时，相应的进程都会自
// 动关闭。但是守护进程却能突破这种限制，它被执行开始运转，直到整个系统关闭时才退
// 出。几乎所有的服务器程序如 Apache 和 wu-FTP，都用 daemon 进程的形式实现。很多 Linux
// 下常见的命令如 inetd 和 ftpd，末尾的字母 d 通常就是指 daemon。
// 
// 守护进程的特性：
// 1> 守护进程最重要的特性是后台运行。
// 2> 其次，守护进程必须与其运行前的环境隔离开来。这些环境包括未关闭的文件描述
// 符、控制终端、会话和进程组、工作目录已经文件创建掩码等。这些环境通常是守护进程
// 从父进程那里继承下来的。
// 3> 守护进程的启动方式
// daemon 进程的编程规则
// ⚫ 创建子进程，父进程退出：
//
// 进程组、会话周期、控制终端：
//
// 进程组：是一个或多个进程的集合。进程组有进程组 ID 来唯一标识。除了进程号(PID)
// 之外，进程组 ID（GID）也是一个进程的必备属性。每个进程都有一个组长进程，其组长
// 进程的进程号等于进程组 ID。且该进程组 ID 不会因为组长进程的退出而受影响。
// 会话周期：会话期是一个或多个进程组的集合。通常，一个会话开始于用户登录，终止
// 于用户退出，在此期间该用户运行的所有进程都属于这个会话期。
// 控制终端：由于在 linux 中，每一个系统与用户进行交流的界面称为终端，每一个从此
// 终端开始运行的进程都会依赖这个控制终端。


#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/stat.h>
void Daemon()
{
	const int MAXFD=64;
	int i=0;
	if(fork()!=0)		//父进程退出
		exit(0);
	setsid(); 		//成为新进程组组长和新会话领导，脱离控制终端
	chdir("/"); 		//设置工作目录为根目录
	umask(0); 		//重设文件访问权限掩码
	for(;i<MAXFD;i++) 	//尽可能关闭所有从父进程继承来的文件
		close(i);
}


int main()
{
	Daemon(); //成为守护进程
	while(1){
		sleep(1);
	}
	return 0;
}
